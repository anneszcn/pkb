```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode {
    int val;
    struct ListNode *next;
};
```

哑结点（1.方便对非空链表和空链表统一处理）；2.方便对涉及到第一个结点的操作等特殊情况进行处理，如删除第一个结点等。
```c
struct ListNode *dummyHead=(struct ListNode *)malloc(sizeof(struct ListNode));dummyHead->next=head;
(最后要释放)
...
head=dummyHead->next;
free(dummyHead);
```

插入结点
``` c
//将q插到p之后
q->next=p->next;
p->next=q;
```

删除结点
``` c
//将p之后结点删除
q=p->next;
p->next=q->next;
free(q);
```

移动结点
```c
//           ↓         ↓
//前移：pre_p p...pre_q q，将q移到p之前（实际是移到p前驱之后，也是后移），当p、q重合时也适用
pre_q->next=q->next;
q->next=pre_p->next;
pre_p->next=q;

//           ↓         ↓
//后移：pre_q q... p，将q移动p之后
//solution 1:p,q重合时，结点丢失，内存泄露；当然，可以通过加判断条件来解决
pre_q->next=q->next;
q->next=p->next;
p->next=q;
//solution 2:分4步：保存、先连、删除、恢复
tmp=p->next;        /* 保存 */
p->next=q;          /* 先连 */
pre->next=q->next;  /* 删除 */
q->next=tmp;        /* 恢复 */
```

查找第k个结点
```c
/*
    4种情况：
                k        返回
    1.空链表              NULL
    2.非空链表  <1        NULL
    3.非空链表  >n        NULL
    4.非空链表 1<=k<=n     p
*/
struct ListNode *FindKth(struct ListNode *head,int k)
{
    struct ListNode *p=head;
   
    int i=1;
    while (p && i<k) {
        p=p->next;
        i++;
    }
    
    #if 0
    int i=k;
    while (p && i>1) {
        p=p->next;
        i--;
    }
    #endif
    
    return (k<1)?NULL:p; 
}
```
