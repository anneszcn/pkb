一般地，对于1,2……n；其全排列，共n!项：按字典序排列，与序号1,2，……，n!一一对应——排列<=>序号   
12……n  ---> 1
……     ……  
n……21  ---> n!  
1、已知某个排列，求其序号  
以35142为例，求其序号，可转化为求比该排列小的排列的个数，  
第一位<3：（1,2），其他位数数字任意，总数为：2*4!；  
     =3：第二位<5：（1,2,4；3已出现，排除），总数为：3*3!；  
              =5：第三位<1，（无），总数为：0*2!；  
                       =1，第四位<4，（1,2,3；1,3已出现，排除），总数为：1*1!；  
                                =4，第五位<2,(无，已是最后一位)，总数为：0*0!  
总计：2*4!+3*3!+0*2!+1*1!+0*0!=67  
则所求序号为：67+1=68  
一般地，设排列为X，则其序号为：  
k=a[n-1]*(n-1)!+a[n-2]*(n-2)+...a[2](2-1)!+a[1]*1!+a[0]*0!
其中a[i]表示：（右数第i位，从0开始），未出现的数字中比该位数字小的个数，或其右边比该位数字小的个数  
``` c
int getPermutationOrder(int* nums, int numsSize)
{
	            //0! 1! 2! 3! 4!  5!  6!  7!    8!     9! 
	int factor[]={1, 1, 2, 6, 24,120,720,5040,40320,362880};
	int ans=0;
	
	for (int i=0;i<numsSize;i++) {
		int coef=0;
		for (int j=i+1;j<numsSize;j++)
			if (nums[j]<nums[i]) coef++;
			
		ans += coef*factor[numsSize-1-i];
	}
	
	return ++ans;
}
```
2、给定某个序号，求对应排列  
为上述过程的逆过程，仍以上述例子来说明，求k=68对应排列，k-1=67，  
67/4!=2...19,商2表示：未出现的数字中有2个数比它小（即第3大），则为3；  
                     1 2 3 4 5  
                         ▲  
19/3!=3...1, 商3表示：未出现的数字中有3个数比它小（即第4大），则为5；  
                     1 2 3 4 5  
                         ^   ▲  
1/2!=0...1,  商0表示：未出现的数字中有0个数比它小（即第1大），则为1；  
                     1 2 3 4 5  
                     ▲   ^   ^  
1/1!=1...0， 商1表示：未出现的数字中有1个数比它小（即第2大），则为4；  
                     1 2 3 4 5  
                     ^   ^ ▲ ^   
0/0!=0...0， 商0表示：未出现的数字中有0个数比它小（即第1大），则为2；  
                     1 2 3 4 5  
                     ^ ▲ ^ ^ ^  
``` c
char * getPermutation(int n, int k)
{
	            //0! 1! 2! 3! 4!  5!  6!  7!    8!     9! 
	int factor[]={1, 1, 2, 6, 24,120,720,5040,40320,362880};
	
	char *ans=(char*)malloc(sizeof(char)*(n+1));
	ans[n]='\0';
	
	k--;
	
	int used[n];
	for (int i=0;i<n;i++) 
		used[i]=-1;
		
	//在未出现的元素中第tmp+1大的（从1开始）
	for (int i=0,j;i<n;i++) {
		int tmp=k/factor[n-1-i];
		
		int cnt=0;
		for (j=0;j<n;j++) {
			if (used[j]==-1) cnt++;
			if (cnt==tmp+1) {
				ans[i]=j+1+'0';
				used[j]=j;
				
				break;
			}
		}
		
		k %= factor[n-1-i];	
	}
	
	return ans;
}
```

